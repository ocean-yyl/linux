$()和 ` `  

在 bash shell 中，$( ) 与` ` (反引号) 都可用做命令替换用。

例如   

version=$(uname -r)和version=`uname -r`都可以是version得到内核的版本号

各自的优缺点：
1. `  ` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高，但反单引号容易打错或看错。

2. $()并不是所有shell都支持。

${ } 

${ }用于变量替换。一般情况下，$var 与${var} 并没有什么不一样，但是用 ${ } 会比较精确的界定变量名称的范围。

例如

    $ A=B
    $ echo $AB
    原本是打算先将 $A 的结果替换出来，然后再补一个 B 字母于其后，但在命令行上，真正的结果却是只会提换变量名称为 AB 的值出来…
    若使用 ${ } 就没问题了：
    $ echo ${A}B
    BB

${ }的模式匹配功能：
# 是去掉左边(在键盘上#在$之左边)
% 是去掉右边(在键盘上%在$之右边)
#和%中的单一符号是最小匹配，两个相同符号是最大匹配。

${variable#pattern}：shell在variable中查找，看它是否以给定的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式

${variable##pattern}：shell在variable中查找，看它是否以给定的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最长的匹配模式

${variable%pattern}：shell在variable中查找，看它是否以给定的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式

${variable%%pattern}：shell在variable中查找，看它是否以给定的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式

这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符。

$[] $(()) 
$[]和$(())是一样的，都是进行数学运算的。支持+ - * / %（“加、减、乘、除、取模”）。但是注意，bash只能作整数运算，对于浮点数是当作字符串处理的。
例如：
$ a=5; b=7; c=2
$ echo $(( a+b*c ))
19
$ echo $(( (a+b)/c ))
6
$ echo $(( (a*b)%c))
1

在 $(( )) 中的变量名称，可于其前面加 $ 符号来替换，也可以不用，如：
$(( $a + $b * $c)) 也可得到 19 的结果
此外，$(( )) 还可作不同进位(如二进制、八进位、十六进制)运算，只是，输出结果皆为十进制而已：

echo $((16#2a)) 结果为 42 (16进位转十进制)

[ ] 
为test命令的另一种形式，但要注意：
1.必须在左括号的右侧和右括号的左侧各加一个空格，否则会报错。
2.test命令使用标准的数学比较符号来表示字符串的比较，而用文本符号来表示数值的比较。

3.大于符号或小于符号必须要转义，否则会被理解成重定向。

(( ))及[[ ]] 
分别是[ ]的针对数学比较表达式和字符串表达式的加强版。

其中

[[ ]]中增加模式匹配特效；

(( ))不需要再将表达式里面的大小于符号转义
--------------------- 
作者：Jessica__WEI 
来源：CSDN 
原文：https://blog.csdn.net/u013402321/article/details/80333272 
版权声明：本文为博主原创文章，转载请附上博文链接！